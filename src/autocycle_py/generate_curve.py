from matplotlib import pyplot as plt
import matplotlib.patches as patches
from scipy import interpolate as interp
import time
import numpy as np
import rospy
from autocycle_extras.srv import GetData
from autocycle_extras.msg import Curve, ObjectList
from std_srvs.srv import Empty


# Size of plot
width = 20
height = 20

# Size of each node
node_size = 2

# The dimensions of the graph (how many nodes in each direction)
x_dim = int(width / node_size)
y_dim = int(height / node_size)

# The nodes that have been deemed blocked by an object
blocked_nodes = set()
center_blocked_nodes = set()

# The path being taken
path = []

# Interpolated path
interpolated_path = None

# Starting node
start_node = (y_dim // 2, 0)

# End node
end_node = (y_dim // 2, x_dim-1)

# Heading
desired_heading = 0

# Calculate Padding
padding = 1.6
padding_num = int(padding // node_size)

# ID for the publishes message
iden = 0

# Total time elapsed
tot = 0

def get_change(p1, p2):
    """Calculates difference between nodes"""
    return p2[0] - p1[0], p2[1] - p1[1]


def augment_path(path):
    """Generates intermediary points to assist in interpolation"""
    new_path = [path[0]]

    for ind in range(1, len(path)):
        change = get_change(new_path[-1], path[ind])
        new_path.append((new_path[-1][0]+(change[0]*0.5), new_path[-1][1]+(change[1]*0.5)))
        new_path.append(path[ind])

    return new_path


def reset_vars():
    """Resets variables between calls"""
    global blocked_nodes, center_blocked_nodes, path, interpolated_path

    # The nodes that have been deemed blocked by an object
    blocked_nodes = set()
    center_blocked_nodes = set()

    # The path being taken
    path = []

    # Interpolated path
    interpolated_path = None


def get_node_from_point(point):
    """Takes cartesian point and returns the corresponding node"""
    x, y = point
    return (
        int(((-y) + (height // 2)) // node_size),
        int(x // node_size)
    )


def get_blocked_nodes(obj):
    """Returns the list of nodes that an object is blocking"""
    x1, x2, y1, y2 = obj
    if x2 < x1:
        tmp = x1
        x1 = x2
        x2 = tmp

        tmp = y1
        y1 = y2
        y2 = tmp

    cur_point = [x1, y1]
    vert = x2 - x1 == 0
    if not vert:
        m = (y2 - y1) / (x2 - x1)
        delta_x = node_size/((1+(m**2))**0.5)
    blocked = set()

    while (cur_point[0] < x2) if not vert else (cur_point[1] < y2):
        node = get_node_from_point(cur_point)
        if node not in center_blocked_nodes:
            cur_blocked = [(node[0]+y, node[1]+x) for y in range(-padding_num, padding_num+1) for x in range(-padding_num, padding_num+1) if 0 <= node[0]+y < y_dim and 0 <= node[1]+x < x_dim]
            blocked.update(cur_blocked)
            center_blocked_nodes.add(node)

        if not vert:
            cur_point = [cur_point[0] + delta_x, cur_point[1] + (m * delta_x)]
        else:
            cur_point[1] += node_size
    node = get_node_from_point([x2, y2])
    if node not in center_blocked_nodes:
        cur_blocked = [(node[0] + y, node[1] + x) for y in range(-padding_num, padding_num + 1) for x in
                       range(-padding_num, padding_num + 1) if (node[0] + y, node[1] + x)]
        blocked.update(cur_blocked)
        center_blocked_nodes.add(node)
    return blocked


def inter_path():
    """Creates the interpolated path from the line segments
    generated by the BFS"""

    ys, xs = zip(*path)
    ys = list(map(lambda y: -(y*node_size) + (height//2), ys))
    xs = list(map(lambda x: (x*node_size) + (node_size * 2) - node_size, xs))
    xs.insert(0, 0)
    ys.insert(0, 0)
    this_tck, u = interp.splprep([xs, ys], s=0.5)
    return u, this_tck


def plot(obj_lst, theta, node_type=0, plot_path=0, save=False, name=""):
    """Plots obstacles, blocked nodes, and curve"""
    fig, ax = plt.subplots()

    # Plots the nodes
    for y_ind in range(y_dim):
        for x_ind in range(x_dim):
            if node_type == 1:
                # Plots all nodes
                rect = patches.Rectangle((x_ind*node_size, (-y_ind*node_size) + (height//2) - node_size), node_size, node_size, linewidth=1, edgecolor='black', facecolor=("black" if (y_ind, x_ind) in blocked_nodes else "none"))
                ax.add_patch(rect)
            elif node_type == 2:
                # Plots only blocked Nodes
                if (y_ind, x_ind) in blocked_nodes:
                    rect = patches.Rectangle((x_ind * node_size, (-y_ind * node_size) + (height//2) - node_size), node_size, node_size, linewidth=1,
                                                edgecolor='black',
                                                facecolor="black")
                    ax.add_patch(rect)

    if plot_path == 1:
        #Plots the path
        f = interpolated_path[1]
        u = np.linspace(0, 1, 1000)
        i = interp.splev(u, f)
        plt.plot(i[0], i[1])
    elif plot_path == 2:
        ys, xs = zip(*path)
        ys = list(map(lambda y: -(y * node_size) + (height // 2), ys))
        xs = list(map(lambda x: (x * node_size) + (node_size * 2) - node_size, xs))
        xs.insert(0, 0)
        ys.insert(0, 0)
        plt.plot(xs, ys)

    # Plot the obstacles
    for o in obj_lst:
        plt.plot(o[0:2], o[2:], linewidth=3)

    # Plots the current and desired heading
    plt.plot([0, width], [0, 0], "--", c="g")
    des_f = lambda x: [np.tan(theta)*i for i in x]
    xs = np.linspace(0, width, 100)
    plt.plot(xs, des_f(xs), "--", c="purple")

    # Sets up and shows plot
    plt.axis("square")
    plt.xlim(0, 20)
    plt.ylim(-10, 10)
    if save:
        if name == "":
            print("YOU DIDNT PROVIDE A NAME!!!!!")
            return
        plt.savefig(name)
    plt.show()


def bfs():
    """Finds the shortest path from the starting node to the
    end node via a Breadth First Search(BFS)"""
    queue = [start_node]
    visited = set()
    parent = {}
    this_path = []

    while queue:
        next_node = queue.pop(0)
        y = next_node[0]
        x = next_node[1]
        adj_nodes = [(y, x+1), (y-1, x+1), (y+1, x+1), (y+1, x), (y-1, x)]
        visited.add(next_node)
        for node in adj_nodes:
            if not(0 <= node[0] <= y_dim) or not(0 <= node[1] <= x_dim) or node in blocked_nodes:
                continue
            if node in visited or node in queue:
                continue
            queue.append(node)
            parent[node] = next_node
            if node == end_node:
                queue = []
                break

    cur_node = end_node
    while cur_node != start_node:
        this_path.append(cur_node)
        try:
            cur_node = parent[cur_node]
        except KeyError:
            print("THE BIKE SHOULD BE STOPPED") # TODO: stop the bike
            break

    this_path.append(start_node)
    return this_path[::-1]


def update_end_node(theta):
    """Updates end_node to approximate the desired heading"""
    global end_node

    if theta == 0:
        return

    m = np.tan(theta)
    half_height = height//2
    top = get_node_from_point((half_height/m, half_height))
    bot = get_node_from_point(((-half_height)/m, -half_height))
    right = get_node_from_point((width, m*(width)))

    if 0 <= top[1] < x_dim:
        end_node = top
    elif 0 <= bot[1] < x_dim:
        end_node = bot
    else:
        end_node = right


def generate_curve(req):
    """Creates the curve around objects"""
    global blocked_nodes, path, interpolated_path, iden, tot

    start = time.time()
    reset_vars()

    ## Creates the Service Client that will get speed data
    data_getter = rospy.ServiceProxy("get_data", GetData)

    new_data = rospy.ServiceProxy("collect_data", Empty)
     
    pub = rospy.Publisher('cycle/curve', Curve, queue_size=1) 

    theta = desired_heading - data_getter(2).data

    update_end_node(theta)
    print(end_node)

    obj_lst = list(map(lambda x: (x.z1 / 1000, x.z2 / 1000, x.x1 / 1000, x.x2 / 1000), req.obj_lst))

    for o in obj_lst:
        blocked_nodes = blocked_nodes.union(get_blocked_nodes(o))
    path = augment_path(augment_path(bfs()))

    interpolated_path = inter_path()

    end = time.time()
    #plot(obj_lst, theta, 0, 1)

    tck = interpolated_path[1]
    pub.publish(tck[0].tolist(), tck[1][0].tolist(), tck[1][1].tolist(), tck[2], iden)
    iden += 1
    end = time.time()
    dur = end - start
    tot += dur
    rospy.loginfo(f"Path Generated in {dur} seconds")
    rospy.loginfo(f"Currently running at {(iden+1)/tot} FPS")
    new_data()
    new_data.close()
    return


def start():
    """Starts the ros node and prepares the relevant services"""
    global des_heading
    # Initialize the node and register it with the master.
    rospy.init_node("bezier")

    # Waits for data getter service
    rospy.wait_for_service('get_data')

    rospy.wait_for_service("collect_data")

    # Creates the service client that will collect data
    data_getter = rospy.ServiceProxy("get_data", GetData)

    new_data = rospy.ServiceProxy("collect_data", Empty)

    ## Sets desired heading (for now the intial heading)
    des_heading = data_getter("heading").data

    rospy.Subscriber("cycle/object_frame", ObjectList, generate_curve)

    ## Closes this data getter
    data_getter.close()

    new_data()

    rospy.spin()
